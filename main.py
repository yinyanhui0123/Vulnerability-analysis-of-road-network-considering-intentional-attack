#!/usr/bin/env python
# coding: utf-8

# In[20]:


#引入相关库
import numpy as np
import networkx as nx
import scipy.io as scio
from fractions import Fraction


# In[21]:


#初始参数设置(输入)
dis_matrix_file_path = '距离矩阵.mat'
adj_matrix_file_path = '邻接矩阵.mat'
#负载可调参数
a = 0.1 
#节点容忍系数
b = 0.1 
#失效系数
c = 1.1 
#节点恢复率
d = 1.1 
#恢复系数
e = 0.1 


# In[13]:


#选择攻击方式
def select_attack(m_graph):
    #读数据
    lst = []
    a = dict(m_graph.degree())
    b = nx.betweenness_centrality(m_graph)
    c = nx.closeness_centrality(m_graph)
    sorted_DA =sorted(a,key = a.get,reverse = True)
    sorted_BA =sorted(b,key = b.get,reverse=True)
    sorted_TA = sorted(c,key = c.get,reverse=True)
    d = input('请输入你的蓄意攻击方式\n1.Degree Attack\n2.Betweenness Attack\n3.Tightness Attack')
    if d=='1':
        e = input(f'按照节点度排序从大到小结果为{sorted_DA}，请选择你要攻击的节点名称')
        initial_failed_nodes = e.split(',')
    if d=='2':  
        e = input(f'按照节点度排序从大到小结果为{sorted_BA}，请选择你要攻击的节点名称')
        initial_failed_nodes = e.split(',')
    if d=='3':  
        e = input(f'按照节点度排序从大到小结果为{sorted_TA}，请选择你要攻击的节点名称')
        initial_failed_nodes = e.split(',')
    return initial_failed_nodes

#删除失效节点
def delete_point(m_graph,failed_nodes):
    failed_nodes = [int(x) for x in failed_nodes] #转化为数字
    for node in failed_nodes:
        m_graph.remove_node(node)


#更新网络状态信息
def update_state(m_graph,f_t1_dict,C_t0_dict,c,d):#c表示节点的失效率，d表示节点的恢复率
    failed_nodes1 = []
    for remain_node in  m_graph.nodes():
        #在上一个状态为0的前提下
        if m_graph.nodes[remain_node]['state'] ==0:
            if f_t1_dict[remain_node]<=C_t0_dict[remain_node]:
                m_graph.nodes[remain_node]['state'] ==0
            elif C_t0_dict[remain_node]<=f_t1_dict[remain_node]<=c*C_t0_dict[remain_node]:
                m_graph.nodes[remain_node]['state'] ==(f_t1_dict[remain_node]-C_t0_dict[remain_node])/(c*C_t0_dict[remain_node]-C_t0_dict[remain_node])
                #加入到部分失效集合
                pfailure_set.append(remain_node)
            elif f_t1_dict[remain_node]>=c*C_t0_dict[remain_node]:
                m_graph.nodes[remain_node]['state'] ==1
                #将符合状态为1的加入到完全失效集合
                cfailure_set.append(remain_node)
            
        #在上一个状态为1-0之间的前提下
        if 0<m_graph.nodes[remain_node]['state']<1:
            if f_t1_dict[remain_node]<=C_t0_dict[remain_node]:
                m_graph.nodes[remain_node]['state'] ==0
                #从原来的集合中删除
                pfailure_set.remove(remain_node)
            elif C_t0_dict[remain_node]<=f_t1_dict[remain_node]<=c*C_t0_dict[remain_node]:
                m_graph.nodes[remain_node]['state'] ==(f_t1_dict[remain_node]-C_t0_dict[remain_node])/(c*C_t0_dict[remain_node]-C_t0_dict[remain_node])
            elif f_t1_dict[remain_node]>=c*C_t0_dict[remain_node]:
                m_graph.nodes[remain_node]['state'] ==1
                 #在原来的集合中去掉，然后加入到新的集合中
                pfailure_set.remove(remain_node)
                cfailure_set.append(remain_node)
                
        #在上一个状态为1的前提下
        if m_graph.nodes[remain_node]['state']==1:
            if 0<d<1:
                m_graph.nodes[remain_node]['state'] ==(f_t1_dict[remain_node]-C_t0_dict[remain_node])/(c*C_t0_dict[remain_node]-C_t0_dict[remain_node])
                cfailure_set.remove(remain_node)
                pfailure_set.append(remain_node)
            else:
                m_graph.nodes[remain_node]['state'] ==1
                failed_nodes1.append(remain_node)
    return failed_nodes1

 #根据状态更新配载     
def update_network(m_graph,f_t1_dict,C_t0_dict,c,d):# c表示节点的失效率，d表示节点的恢复率
    f_t2_dict = f_t1_dict.copy()
    for remain_node in m_graph.nodes():
        if 0<m_graph.nodes[remain_node]['state'] <1:
            p =(f_t1_dict[remain_node]-C_t0_dict[remain_node])/(c*C_t0_dict[remain_node]-C_t0_dict[remain_node])
            p_val = pow(p,c)
            f_t2_dict[remain_node] = f_t1_dict[remain_node]*p_val
            #找出邻居中不是失效的个数
            k=0
            for neibor in list(m_graph.neighbors(remain_node)):
                if m_graph.nodes[neibor]['state'] !=0:
                    k=k+1
            a = len(list(m_graph.neighbors(remain_node)))-k 
            #不是失效的邻居进行计算
            for neibor in list(m_graph.neighbors(remain_node)):
                if m_graph.nodes[neibor]['state'] ==0:
                    f_t2_dict[neibor] = f_t1_dict[neibor]+(1-p_val)*f_t1_dict[neibor]*(1/a)
        if m_graph.nodes[remain_node]['state'] ==1:
            f_t2_dict[remain_node] = C_t0_dict[remain_node]+(c*C_t0_dict[remain_node]-C_t0_dict[remain_node])*(1-d)
            k=0
            for neibor in list(m_graph.neighbors(remain_node)): 
                if m_graph.nodes[neibor]['state'] !=0:
                    k=k+1
            a = len(list(m_graph.neighbors(remain_node)))-k 
            #不是失效的邻居进行计算
            for neibor in list(m_graph.neighbors(remain_node)):
                if m_graph.nodes[neibor]['state'] ==0:
                    f_t2_dict[neibor] = f_t1_dict[neibor]+(f_t1_dict[remain_node]-f_t2_dict[remain_node])*(1/a)
    return f_t2_dict


# In[33]:


#步骤1：初始化
disMertix = scio.loadmat(dis_matrix_file_path)
disMertix = disMertix['b']

#邻接矩阵
adjMetrix = scio.loadmat(adj_matrix_file_path)
adjMetrix = adjMetrix['a']

weight_edge = disMertix*adjMetrix
#创建图像
m_graph = nx.Graph()
#加权加邻接矩阵
m_graph = nx.from_numpy_array(weight_edge)
#显示边的信息
m_graph.edges(data=True) 
#输出邻接矩阵
#A = nx.adjacency_matrix(m_graph).todense() 
#后边有用
m1_graph = m_graph.copy()


# In[34]:


#步骤2：计算各节点的节点度d(t)，介数值B(t)，紧密度TD(t)
d_val = [i[1] for i in m_graph.degree()] #获取每个节点的节点度加入列表（形式为列表加元组）
d_val_dict = dict(zip(list(m1_graph.nodes),d_val))
B_t0 =[j for j in nx.betweenness_centrality(m_graph).values()] #获取每个节点的介数（形式为字典）
TD_t0 = [t for t in nx.closeness_centrality(m_graph).values()] #获取每个节点的接近度（形式为字典）


# In[147]:


#步骤3：计算初始节点负载集合以及节点容量集合
#1.计算初始化节点负载集合
#1.1 相关变量变为数组形式
d_t0 = np.array(d_val)
f_t0_lst = []
# 1.2 计算
for i in range(len(adjMetrix)):
    d_t0_relax =np.sum(d_t0[i]*adjMetrix[i,:])
    d_val1 = d_t0[i]*d_t0_relax
    f_t0 = np.power(d_val1,a)
    f_t0_lst.append(f_t0)
#2. 计算节点容量C
f_t0_array = np.array(f_t0_lst)
C_t0 =(1+b)*f_t0_array

#3.以字典形式保存，方便查找删除
f_t0_dict = dict(zip(list(m1_graph.nodes),f_t0_lst))
C_t0_dict = dict(zip(list(m1_graph.nodes),C_t0.tolist()))


# In[38]:


#步骤4：选择初始失效节点

#1.初始认为所有节点都是正常的，修改节点前copy一下图网络
for node in m_graph.nodes():
    m_graph.nodes[node]['state'] = 0

#2.选择攻击方式。
initial_failed_nodes = select_attack(m_graph)


#3.建立正常节点集合，部分失效节点集合，完全失效节点集合,将攻击的点加入对应集合
normal_set = []
pfailure_set = []
cfailure_set = []
cfailure_set.append(initial_failed_nodes)



# In[122]:


#步骤5：重新分配交通负载
#1. AD策略 
#1.1 遍历失效节点邻居的状态，看是不是失效节点(先将列表中str格式变为数字)
initial_failed_nodes = [int(x) for x in initial_failed_nodes]
f_t1_dict = f_t0_dict.copy()
for failed_node in initial_failed_nodes:
    k=0
    for neibor in list(m_graph.neighbors(failed_node)):
        if m_graph.nodes[neibor]['state'] !=0:
            k=k+1
    a = len(list(m_graph.neighbors(failed_node)))-k
    
#1.2 开始分配
    for neibor in list(m_graph.neighbors(failed_node)):
        if m_graph.nodes[neibor]['state'] ==0:
            #计算f(t+1)
            f_t1_dict[neibor] = f_t0_dict[neibor]+f_t0_dict[failed_node]*(1/a)
               
#2删除失效节点
delete_point(m_graph,initial_failed_nodes)


# In[2]:


#步骤6：更新网络相关信息
#1.遍历现在剩余的节点,更新状态+分配集合
while True:
    failed_nodes1 = update_state(m_graph,f_t1_dict,C_t0_dict,c,d)
    


# In[35]:


#步骤7：根据负载分配后各节点状态，更新负载分配情况，计算下一时刻负载情况
#1.遍历各节点，根据状态更新负载分配
    f_t1_dict = update_network(m_graph,f_t1_dict,C_t0_dict,c,d)

#2.计算修正的最大连通量和基于节点度的节点失效率
    #2.1 首先整合一下正常节点的节点集合
    all_node = [x for x in m1_graph.nodes()]
    for i in  pfailure_set+cfailure_set:
        all_node.remove(i)
    normal_set = all_node
    

    #2.2 计算f(t+2)最大连通量
    normal_set_array = np.array(normal_set)
    pfailure_set_array = np.array(pfailure_set)
    cfailure_set_array = np.array(cfailure_set_array)
    N_sum = 0
    sum1 = 0
    sum2 = 0
    for node_pf in pfailure_set:
        k =(f_t1_dict[node_pf]-C_t0_dict[node_pf])/(c*C_t0_dict[node_pf]-C_t0_dict[node_pf])
        N_sum + = (1-k)
    G_val = N_sum/len(m_graph.nodes())


    #2.3 计算f(t+2)的基于节点度的节点失效率
    for node_pf in pfailure_set:
        k = (f_t1_dict[node_pf]-C_t0_dict[node_pf])/(c*C_t0_dict[node_pf]-C_t0_dict[node_pf])
        k1 = d_val_dict[node_pf]*k
        sum1 += k1 
    for node_cf in cfailure_set:
        sum2 + = d_val_dict[node_cf]

    I_val = (sum2+sum1)/sum(d_val)

#2.如果d不在0到1之间就会有删除的节点
    if len(failed_nodes1)!=0:
        delete_point(m_graph,failed_nodes1)

        
#3.遍历所有节点的状态，如果所有点都为0时终止
    m=0
    for remain_node in m_graph.nodes():
        m+=graph.nodes[remain_node]['state']
        if m==0:
            break
            
    


# In[46]:




